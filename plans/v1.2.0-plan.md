# Content Management System - Version 1.2.0 Implementation Plan

## ğŸ“‹ Overview

**Version:** 1.2.0  
**Status:** Planning  
**Target Release:** Q1 2026  
**Current Version:** 1.0.0

This document outlines the implementation plan for version 1.2.0 of the Content Management System, introducing enterprise-grade features including authentication, caching, rate limiting, advanced querying, and GraphQL support.

---

## ğŸ¯ Goals & Objectives

### Primary Goals

1. **Security Enhancement**: Implement robust authentication and authorization using JWT with Supabase Auth
2. **Performance Optimization**: Integrate Redis for caching and improved response times
3. **API Protection**: Deploy rate limiting to prevent abuse and ensure fair resource usage
4. **Developer Experience**: Add GraphQL API alongside REST for flexible data querying
5. **User Experience**: Implement pagination, sorting, and filtering for better data management

### Success Metrics

- Authentication response time < 200ms
- Cache hit ratio > 70%
- API response time improvement of 40%+
- Rate limiting preventing > 95% of abuse attempts
- GraphQL query complexity management

---

## ğŸ—ï¸ Architecture Overview

### System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Client Layer                          â”‚
â”‚                    (REST/GraphQL Clients)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚                       â”‚
                 v                       v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   REST API Endpoints   â”‚  â”‚   GraphQL Endpoint       â”‚
â”‚   (Gin Framework)      â”‚  â”‚   (gqlgen)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                              â”‚
         v                              v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Middleware Layer                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   CORS   â”‚ â”‚ Rate Limiterâ”‚ â”‚    Auth    â”‚ â”‚  Logger  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Business Logic Layer                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚Controllers â”‚ â”‚  Services  â”‚ â”‚  Resolvers â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                          â”‚
         v                          v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Redis Cache    â”‚    â”‚   PostgreSQL Database    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Sessions  â”‚  â”‚    â”‚  â”‚  Pages / Posts /   â”‚ â”‚
â”‚  â”‚  Cache     â”‚  â”‚    â”‚  â”‚  Media / Users     â”‚ â”‚
â”‚  â”‚  Rate Limitâ”‚  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Supabase Auth (External)         â”‚
â”‚    OAuth Providers & JWT Validation      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ Feature Breakdown

## Feature 1: JWT Authentication with Supabase Auth/OAuth

### 1.1 Overview

Implement secure authentication using JSON Web Tokens (JWT) with Supabase as the authentication provider, supporting OAuth flows for social login providers.

### 1.2 Technical Design

#### Components

1. **Authentication Middleware**

   - JWT token validation
   - Token refresh mechanism
   - User context injection

2. **Supabase Integration**

   - Supabase client initialization
   - OAuth provider configuration (Google, GitHub, etc.)
   - User session management

3. **User Model**
   - User entity in database
   - Role-based access control (RBAC)
   - User permissions mapping

#### Database Schema

```sql
-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255),
    avatar_url TEXT,
    role VARCHAR(50) DEFAULT 'user' CHECK (role IN ('admin', 'editor', 'user')),
    supabase_id VARCHAR(255) UNIQUE,
    is_active BOOLEAN DEFAULT true,
    last_login_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- User sessions (for tracking)
CREATE TABLE user_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token_jti VARCHAR(255) UNIQUE,
    ip_address VARCHAR(45),
    user_agent TEXT,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Add user_id to existing tables
ALTER TABLE posts ADD COLUMN user_id UUID REFERENCES users(id);
ALTER TABLE pages ADD COLUMN user_id UUID REFERENCES users(id);
ALTER TABLE media ADD COLUMN user_id UUID REFERENCES users(id);
```

### 1.3 Implementation Steps

#### Phase 1: Foundation (Days 1-2)

1. **Setup Supabase Project**

   - Create Supabase project
   - Configure OAuth providers
   - Set up authentication policies
   - Generate API keys and URLs

2. **Install Dependencies**

   ```bash
   go get github.com/supabase-community/supabase-go
   go get github.com/golang-jwt/jwt/v5
   go get github.com/google/uuid
   ```

3. **Environment Configuration**
   ```env
   SUPABASE_URL=your-project-url.supabase.co
   SUPABASE_KEY=your-anon-key
   SUPABASE_JWT_SECRET=your-jwt-secret
   JWT_EXPIRATION=24h
   ```

#### Phase 2: Core Implementation (Days 3-5)

1. **Create User Model**

   - `src/models/user.go`
   - Define User struct
   - Add GORM hooks and methods

2. **Build Auth Service**

   - `src/services/authService.go`
   - Implement Supabase client wrapper
   - JWT validation logic
   - Token refresh mechanism
   - User synchronization with Supabase

3. **Create Auth Middleware**

   - `src/middleware/auth.go`
   - JWT extraction from headers
   - Token validation
   - User context injection
   - Role-based access control checks

4. **Build Auth Controller**
   - `src/controllers/authController.go`
   - Login endpoint (OAuth redirect)
   - Callback endpoint
   - Logout endpoint
   - Token refresh endpoint
   - Current user endpoint

#### Phase 3: Integration (Days 6-7)

1. **Protect Existing Routes**

   - Update route definitions
   - Apply auth middleware selectively
   - Define public vs protected endpoints

2. **Add User Associations**
   - Update Post, Page, Media controllers
   - Associate created content with users
   - Add user filtering options

### 1.4 API Endpoints

```
POST   /api/v1/auth/login           # Initiate OAuth flow
GET    /api/v1/auth/callback        # OAuth callback
POST   /api/v1/auth/logout          # Logout user
POST   /api/v1/auth/refresh         # Refresh JWT token
GET    /api/v1/auth/me              # Get current user
PUT    /api/v1/auth/profile         # Update user profile
GET    /api/v1/auth/sessions        # List active sessions
DELETE /api/v1/auth/sessions/:id    # Revoke session
```

### 1.5 Security Considerations

- Store JWT secret securely in environment variables
- Implement token expiration and refresh
- Use HTTPS in production
- Implement CSRF protection
- Rate limit authentication endpoints
- Log authentication attempts
- Implement account lockout after failed attempts

---

## Feature 2: Redis Integration

### 2.1 Overview

Integrate Redis as a high-performance caching layer and session store to improve application performance and scalability.

### 2.2 Technical Design

#### Use Cases

1. **Response Caching**

   - Cache GET requests for posts, pages, media
   - Implement cache invalidation strategies
   - TTL-based expiration

2. **Session Storage**

   - Store user sessions
   - Track active users
   - Quick session lookups

3. **Database Query Caching**

   - Cache frequently accessed data
   - Reduce database load
   - Improve response times

4. **Rate Limiting Storage**
   - Track request counts per user/IP
   - Sliding window implementation
   - Efficient lookup and cleanup

### 2.3 Implementation Steps

#### Phase 1: Setup (Days 1-2)

1. **Install Dependencies**

   ```bash
   go get github.com/redis/go-redis/v9
   ```

2. **Docker Compose Update**

   ```yaml
   redis:
     image: redis:7-alpine
     ports:
       - "6379:6379"
     volumes:
       - redis_data:/data
     command: redis-server --appendonly yes
     healthcheck:
       test: ["CMD", "redis-cli", "ping"]
       interval: 5s
       timeout: 3s
       retries: 5
   ```

3. **Environment Configuration**
   ```env
   REDIS_HOST=localhost
   REDIS_PORT=6379
   REDIS_PASSWORD=
   REDIS_DB=0
   CACHE_TTL=300s
   ```

#### Phase 2: Core Implementation (Days 3-5)

1. **Redis Client Setup**

   - `src/utils/redis.go`
   - Initialize Redis client
   - Connection pooling
   - Health check utilities

2. **Cache Service**

   - `src/services/cacheService.go`
   - Generic Get/Set/Delete operations
   - TTL management
   - Serialization/deserialization helpers
   - Cache key generation strategies

3. **Cache Middleware**
   - `src/middleware/cache.go`
   - HTTP response caching
   - Cache-Control header handling
   - Conditional caching based on routes

#### Phase 3: Integration (Days 6-7)

1. **Controller Updates**

   - Add caching to GET endpoints
   - Implement cache invalidation on POST/PUT/DELETE
   - Add cache warming strategies

2. **Query Caching**
   - Cache database query results
   - Implement smart invalidation
   - Track cache hit/miss metrics

### 2.4 Caching Strategy

#### Cache Keys Pattern

```
cms:{entity}:{id}                    # Single entity
cms:{entity}:list:{hash}             # List queries with filters
cms:user:{user_id}:profile           # User-specific data
cms:stats:global                     # Global statistics
```

#### TTL Guidelines

```
Entity Cache:           5 minutes
List Cache:             2 minutes
User Profile:           10 minutes
Statistics:             1 minute
Session Data:           24 hours
```

#### Invalidation Rules

- Single entity update: Clear specific cache
- Bulk operations: Clear related list caches
- User actions: Clear user-specific caches
- Admin actions: Clear global caches

### 2.5 Monitoring & Metrics

- Cache hit/miss ratio
- Average response time with/without cache
- Memory usage
- Eviction rates
- Connection pool statistics

---

## Feature 3: Rate Limiter with Redis

### 3.1 Overview

Implement distributed rate limiting using Redis to protect the API from abuse, ensure fair usage, and maintain system stability.

### 3.2 Technical Design

#### Strategy: Sliding Window Counter

- Most accurate rate limiting algorithm
- Smooth rate limiting across time windows
- Redis-backed for distributed systems

#### Rate Limit Tiers

```
Public Endpoints:       100 requests/minute
Authenticated Users:    500 requests/minute
Premium Users:          2000 requests/minute
Admin Users:            No limit
```

### 3.3 Implementation Steps

#### Phase 1: Core Implementation (Days 1-3)

1. **Rate Limiter Service**

   - `src/services/rateLimiterService.go`
   - Sliding window algorithm
   - Multiple tier support
   - IP and user-based limiting

2. **Rate Limiter Middleware**
   - `src/middleware/rateLimiter.go`
   - Extract identifier (IP/User ID)
   - Check rate limits
   - Return 429 status on limit exceeded
   - Add rate limit headers

#### Phase 2: Integration (Days 4-5)

1. **Apply to Routes**

   - Global rate limiting
   - Per-endpoint limits
   - Whitelist/blacklist support

2. **Admin Overrides**
   - Bypass for admin users
   - Dynamic limit adjustment
   - Temporary limit increases

### 3.4 Implementation Details

#### Redis Schema

```
rate_limit:{identifier}:{window}    # Counter for time window
rate_limit:blacklist:{ip}           # Blacklisted IPs
rate_limit:whitelist:{ip}           # Whitelisted IPs
```

#### Response Headers

```
X-RateLimit-Limit:      500
X-RateLimit-Remaining:  499
X-RateLimit-Reset:      1640995200
Retry-After:            60
```

#### Error Response

```json
{
  "error": "Rate limit exceeded",
  "message": "Too many requests. Please try again in 60 seconds.",
  "limit": 500,
  "remaining": 0,
  "reset_at": "2024-12-02T12:00:00Z"
}
```

### 3.5 Advanced Features

- Burst allowance for short spikes
- Cost-based rate limiting (heavier endpoints cost more)
- Geographic-based limits
- Endpoint-specific limits
- Automatic blacklisting for abuse

---

## Feature 4: Pagination, Sorting & Filtering

### 4.1 Overview

Implement comprehensive query capabilities for all list endpoints to handle large datasets efficiently and provide flexible data retrieval.

### 4.2 Technical Design

#### URL Query Parameters

```
# Pagination
?page=1&limit=20&offset=0

# Sorting
?sort=created_at&order=desc
?sort=title,created_at&order=asc,desc

# Filtering
?status=published
?title=contains:blog
?created_at=gte:2024-01-01
?user_id=eq:uuid

# Search
?search=keyword
?search_fields=title,content,description
```

### 4.3 Implementation Steps

#### Phase 1: Query Builder (Days 1-2)

1. **Query Parser**

   - `src/utils/queryParser.go`
   - Parse pagination parameters
   - Parse sorting parameters
   - Parse filter parameters
   - Validation and sanitization

2. **Query Builder**
   - `src/utils/queryBuilder.go`
   - Build GORM queries dynamically
   - Apply pagination
   - Apply sorting
   - Apply filters
   - Handle relationships

#### Phase 2: Controller Integration (Days 3-4)

1. **Update List Endpoints**

   - Modify GetAll methods in controllers
   - Apply query builder
   - Return metadata (total count, pages, etc.)

2. **Response Format**
   ```json
   {
     "data": [...],
     "meta": {
       "page": 1,
       "limit": 20,
       "total": 150,
       "total_pages": 8,
       "has_next": true,
       "has_prev": false
     },
     "links": {
       "self": "/api/v1/posts?page=1",
       "next": "/api/v1/posts?page=2",
       "prev": null,
       "first": "/api/v1/posts?page=1",
       "last": "/api/v1/posts?page=8"
     }
   }
   ```

### 4.4 Filter Operators

```
eq:       Equal
ne:       Not equal
gt:       Greater than
gte:      Greater than or equal
lt:       Less than
lte:      Less than or equal
in:       In array
nin:      Not in array
contains: String contains
starts:   String starts with
ends:     String ends with
null:     Is null
notnull:  Is not null
```

### 4.5 Performance Optimization

- Add database indexes for sortable fields
- Implement cursor-based pagination for large datasets
- Cache count queries
- Limit maximum page size
- Default sensible limits

---

## Feature 5: GraphQL API

### 5.1 Overview

Implement a GraphQL API alongside the existing REST API using gqlgen, providing clients with flexible data querying capabilities and reducing over-fetching.

### 5.2 Technical Design

#### Technology Stack

- **gqlgen**: Go GraphQL framework
- **Dataloaders**: Batch and cache database queries (N+1 problem)
- **GraphQL Playground**: Interactive API explorer

#### Schema Design

```graphql
# Types
type User {
  id: ID!
  email: String!
  name: String
  avatarUrl: String
  role: Role!
  posts: [Post!]!
  pages: [Page!]!
  createdAt: Time!
  updatedAt: Time!
}

type Post {
  id: ID!
  title: String!
  content: String!
  excerpt: String
  slug: String!
  status: PostStatus!
  author: User!
  media: [Media!]!
  tags: [String!]!
  createdAt: Time!
  updatedAt: Time!
  publishedAt: Time
}

type Page {
  id: ID!
  title: String!
  content: String!
  slug: String!
  status: PageStatus!
  author: User!
  template: String
  parentPage: Page
  childPages: [Page!]!
  createdAt: Time!
  updatedAt: Time!
}

type Media {
  id: ID!
  filename: String!
  filepath: String!
  mimetype: String!
  size: Int!
  url: String!
  uploader: User!
  createdAt: Time!
}

# Enums
enum Role {
  ADMIN
  EDITOR
  USER
}

enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum PageStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

# Input Types
input CreatePostInput {
  title: String!
  content: String!
  excerpt: String
  slug: String
  status: PostStatus!
  tags: [String!]
}

input UpdatePostInput {
  title: String
  content: String
  excerpt: String
  slug: String
  status: PostStatus
  tags: [String!]
}

input PostFilter {
  status: PostStatus
  authorId: ID
  search: String
  tags: [String!]
  createdAfter: Time
  createdBefore: Time
}

input PaginationInput {
  page: Int! = 1
  limit: Int! = 20
}

input SortInput {
  field: String!
  order: SortOrder! = ASC
}

enum SortOrder {
  ASC
  DESC
}

# Paginated Response
type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PostEdge {
  cursor: String!
  node: Post!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

# Queries
type Query {
  # User queries
  me: User
  user(id: ID!): User
  users(
    filter: UserFilter
    pagination: PaginationInput
    sort: SortInput
  ): UserConnection!

  # Post queries
  post(id: ID, slug: String): Post
  posts(
    filter: PostFilter
    pagination: PaginationInput
    sort: SortInput
  ): PostConnection!

  # Page queries
  page(id: ID, slug: String): Page
  pages(
    filter: PageFilter
    pagination: PaginationInput
    sort: SortInput
  ): PageConnection!

  # Media queries
  media(id: ID!): Media
  mediaList(
    filter: MediaFilter
    pagination: PaginationInput
    sort: SortInput
  ): MediaConnection!

  # Statistics
  stats: Statistics!
}

# Mutations
type Mutation {
  # Post mutations
  createPost(input: CreatePostInput!): Post!
  updatePost(id: ID!, input: UpdatePostInput!): Post!
  deletePost(id: ID!): Boolean!
  publishPost(id: ID!): Post!

  # Page mutations
  createPage(input: CreatePageInput!): Page!
  updatePage(id: ID!, input: UpdatePageInput!): Page!
  deletePage(id: ID!): Boolean!

  # Media mutations
  uploadMedia(file: Upload!): Media!
  deleteMedia(id: ID!): Boolean!

  # User mutations
  updateProfile(input: UpdateProfileInput!): User!
}

# Subscriptions (Future enhancement)
type Subscription {
  postCreated: Post!
  postUpdated(id: ID!): Post!
  commentAdded(postId: ID!): Comment!
}

# Custom Scalars
scalar Time
scalar Upload
```

### 5.3 Implementation Steps

#### Phase 1: Setup (Days 1-2)

1. **Install gqlgen**

   ```bash
   go get github.com/99designs/gqlgen
   go run github.com/99designs/gqlgen init
   ```

2. **Project Structure**

   ```
   src/
   â”œâ”€â”€ graph/
   â”‚   â”œâ”€â”€ schema/
   â”‚   â”‚   â”œâ”€â”€ schema.graphqls       # Main schema
   â”‚   â”‚   â”œâ”€â”€ post.graphqls         # Post types
   â”‚   â”‚   â”œâ”€â”€ page.graphqls         # Page types
   â”‚   â”‚   â”œâ”€â”€ media.graphqls        # Media types
   â”‚   â”‚   â””â”€â”€ user.graphqls         # User types
   â”‚   â”œâ”€â”€ model/
   â”‚   â”‚   â””â”€â”€ models_gen.go         # Generated models
   â”‚   â”œâ”€â”€ generated.go              # Generated resolver
   â”‚   â””â”€â”€ resolver.go               # Root resolver
   â”œâ”€â”€ resolvers/
   â”‚   â”œâ”€â”€ post.resolvers.go
   â”‚   â”œâ”€â”€ page.resolvers.go
   â”‚   â”œâ”€â”€ media.resolvers.go
   â”‚   â””â”€â”€ user.resolvers.go
   â””â”€â”€ dataloaders/
       â”œâ”€â”€ dataloaders.go
       â””â”€â”€ generated/
   ```

3. **Configuration**
   - `gqlgen.yml` configuration file
   - Custom scalar implementations
   - Model mapping to existing models

#### Phase 2: Schema & Resolvers (Days 3-7)

1. **Define GraphQL Schema**

   - Create schema files
   - Generate code with gqlgen

2. **Implement Resolvers**

   - Query resolvers for each type
   - Mutation resolvers for each type
   - Field resolvers for relationships

3. **Dataloader Implementation**
   - User dataloader (batch load users)
   - Media dataloader (batch load media)
   - Prevent N+1 query problems

#### Phase 3: Integration (Days 8-9)

1. **GraphQL Endpoint**

   - Mount GraphQL handler at `/graphql`
   - Enable GraphQL Playground at `/playground`
   - Add authentication middleware

2. **Error Handling**

   - Custom error formatting
   - Error codes and messages
   - Validation errors

3. **Complexity Analysis**
   - Query complexity limits
   - Depth limits
   - Prevent expensive queries

### 5.4 GraphQL Middleware

```go
// Complexity limit
ComplexityLimit: 1000

// Query depth limit
QueryDepthLimit: 10

// Disable introspection in production
DisableIntrospection: env == "production"
```

### 5.5 Example Queries

#### Query Posts with Author

```graphql
query GetPosts {
  posts(
    filter: { status: PUBLISHED }
    pagination: { page: 1, limit: 10 }
    sort: { field: "createdAt", order: DESC }
  ) {
    edges {
      node {
        id
        title
        excerpt
        author {
          name
          email
          avatarUrl
        }
        media {
          url
          filename
        }
        createdAt
      }
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
```

#### Create Post Mutation

```graphql
mutation CreatePost {
  createPost(
    input: {
      title: "New Blog Post"
      content: "Content here..."
      excerpt: "Short description"
      status: PUBLISHED
      tags: ["golang", "graphql"]
    }
  ) {
    id
    title
    slug
    createdAt
  }
}
```

---

## ğŸ“… Implementation Timeline

### Phase 1: Foundation (Weeks 1-2)

- **Week 1**
  - Day 1-2: Supabase setup and authentication foundation
  - Day 3-5: JWT middleware and auth controller
  - Day 6-7: User model and database migrations
- **Week 2**
  - Day 1-2: Redis setup and Docker configuration
  - Day 3-5: Cache service implementation
  - Day 6-7: Cache middleware and integration

### Phase 2: Core Features (Weeks 3-4)

- **Week 3**
  - Day 1-3: Rate limiter service and middleware
  - Day 4-5: Rate limiter integration and testing
  - Day 6-7: Query parser and builder for pagination/filtering
- **Week 4**
  - Day 1-2: Controller updates for pagination/sorting
  - Day 3-4: Filter implementation
  - Day 5-7: GraphQL setup and schema design

### Phase 3: GraphQL Development (Weeks 5-6)

- **Week 5**
  - Day 1-3: Resolver implementation
  - Day 4-5: Dataloader setup
  - Day 6-7: GraphQL middleware and error handling
- **Week 6**
  - Day 1-2: Integration testing
  - Day 3-4: Performance optimization
  - Day 5-7: Documentation and examples

### Phase 4: Testing & Documentation (Week 7)

- **Week 7**
  - Day 1-2: Unit tests for all features
  - Day 3-4: Integration tests
  - Day 5: Performance testing and optimization
  - Day 6: Documentation and API examples
  - Day 7: Final review and bug fixes

### Phase 5: Deployment Preparation (Week 8)

- **Week 8**
  - Day 1-2: Production configuration
  - Day 3-4: Security audit
  - Day 5: Staging deployment
  - Day 6-7: Final testing and release preparation

**Total Duration:** 8 weeks (56 days)

---

## ğŸ“¦ Dependencies & Tools

### New Go Dependencies

```go
// Authentication
github.com/supabase-community/supabase-go    // Supabase client
github.com/golang-jwt/jwt/v5                 // JWT handling
github.com/google/uuid                       // UUID generation

// Redis
github.com/redis/go-redis/v9                 // Redis client

// GraphQL
github.com/99designs/gqlgen                  // GraphQL server
github.com/vektah/dataloaden                 // Dataloader generator
github.com/graph-gophers/dataloader/v7       // Dataloader implementation

// Utilities
github.com/go-playground/validator/v10       // Input validation
github.com/spf13/viper                       // Configuration management
golang.org/x/time/rate                       // Rate limiting utilities
```

### External Services

- **Supabase** (Authentication)
  - Project setup
  - OAuth configuration
  - JWT secret management

### Infrastructure

- **Redis 7.x** (Caching & Rate Limiting)
  - Docker container
  - Persistence configuration
  - Monitoring setup

### Development Tools

- **GraphQL Playground** (API Testing)
- **Redis Commander** (Redis GUI)
- **Postman** (API Testing)
- **k6** (Load Testing)

---

## ğŸ—„ï¸ Database Migrations

### Migration Files to Create

1. **000004_create_users_table.up.sql**

   ```sql
   CREATE TABLE users (
       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
       email VARCHAR(255) UNIQUE NOT NULL,
       name VARCHAR(255),
       avatar_url TEXT,
       role VARCHAR(50) DEFAULT 'user' CHECK (role IN ('admin', 'editor', 'user')),
       supabase_id VARCHAR(255) UNIQUE,
       is_active BOOLEAN DEFAULT true,
       last_login_at TIMESTAMP,
       created_at TIMESTAMP DEFAULT NOW(),
       updated_at TIMESTAMP DEFAULT NOW()
   );

   CREATE INDEX idx_users_email ON users(email);
   CREATE INDEX idx_users_supabase_id ON users(supabase_id);
   CREATE INDEX idx_users_role ON users(role);
   ```

2. **000005_create_user_sessions_table.up.sql**

   ```sql
   CREATE TABLE user_sessions (
       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
       user_id UUID REFERENCES users(id) ON DELETE CASCADE,
       token_jti VARCHAR(255) UNIQUE,
       ip_address VARCHAR(45),
       user_agent TEXT,
       expires_at TIMESTAMP NOT NULL,
       created_at TIMESTAMP DEFAULT NOW()
   );

   CREATE INDEX idx_user_sessions_user_id ON user_sessions(user_id);
   CREATE INDEX idx_user_sessions_token_jti ON user_sessions(token_jti);
   CREATE INDEX idx_user_sessions_expires_at ON user_sessions(expires_at);
   ```

3. **000006_add_user_references.up.sql**

   ```sql
   ALTER TABLE posts ADD COLUMN user_id UUID REFERENCES users(id);
   ALTER TABLE pages ADD COLUMN user_id UUID REFERENCES users(id);
   ALTER TABLE media ADD COLUMN user_id UUID REFERENCES users(id);

   CREATE INDEX idx_posts_user_id ON posts(user_id);
   CREATE INDEX idx_pages_user_id ON pages(user_id);
   CREATE INDEX idx_media_user_id ON media(user_id);
   ```

4. **000007_add_performance_indexes.up.sql**

   ```sql
   -- Posts indexes
   CREATE INDEX idx_posts_status ON posts(status);
   CREATE INDEX idx_posts_created_at ON posts(created_at DESC);
   CREATE INDEX idx_posts_slug ON posts(slug);

   -- Pages indexes
   CREATE INDEX idx_pages_status ON pages(status);
   CREATE INDEX idx_pages_created_at ON pages(created_at DESC);
   CREATE INDEX idx_pages_slug ON pages(slug);

   -- Media indexes
   CREATE INDEX idx_media_created_at ON media(created_at DESC);
   CREATE INDEX idx_media_mimetype ON media(mimetype);
   ```

---

## ğŸ§ª Testing Strategy

### Unit Tests

- **Authentication Service**

  - JWT token generation
  - Token validation
  - Token refresh
  - User role checks

- **Cache Service**

  - Get/Set/Delete operations
  - TTL management
  - Serialization

- **Rate Limiter**

  - Sliding window algorithm
  - Multiple tier handling
  - Whitelist/blacklist

- **Query Builder**
  - Pagination logic
  - Sorting logic
  - Filter parsing

### Integration Tests

- **Authentication Flow**

  - Complete OAuth flow
  - Protected route access
  - Token refresh flow

- **Caching Behavior**

  - Cache hit/miss scenarios
  - Cache invalidation
  - TTL expiration

- **Rate Limiting**

  - Request counting
  - Limit enforcement
  - Header presence

- **GraphQL Queries**
  - Query execution
  - Mutation execution
  - Error handling

### Performance Tests

- **Load Testing**

  - Concurrent users: 1000+
  - Request rate: 10k req/min
  - Response time: p95 < 200ms

- **Cache Performance**

  - Hit ratio: > 70%
  - Response time improvement: 40%+

- **Rate Limiter Performance**
  - Overhead: < 5ms per request
  - Memory usage: stable

### Test Coverage Goals

- Unit Test Coverage: 80%+
- Integration Test Coverage: 70%+
- Critical Path Coverage: 100%

---

## ğŸ“Š Performance Targets

### Response Times (p95)

| Endpoint Type   | Without Cache | With Cache |
| --------------- | ------------- | ---------- |
| Single Entity   | 50ms          | 10ms       |
| List (20 items) | 100ms         | 20ms       |
| Complex Query   | 200ms         | 50ms       |
| GraphQL Query   | 150ms         | 30ms       |

### Throughput

- REST API: 5000 req/sec
- GraphQL API: 3000 req/sec
- With Rate Limiting: 500-2000 req/min per user

### Resource Usage

- Memory: < 500MB baseline
- CPU: < 50% under normal load
- Redis Memory: < 1GB
- Connection Pool: 25-100 connections

---

## ğŸ”’ Security Considerations

### Authentication & Authorization

- âœ… JWT secret stored in environment variables
- âœ… Token expiration (24h default)
- âœ… Refresh token rotation
- âœ… HTTPS enforcement in production
- âœ… Secure cookie flags (HttpOnly, Secure, SameSite)
- âœ… CSRF protection
- âœ… Account lockout after failed attempts
- âœ… Rate limiting on auth endpoints (stricter)

### API Security

- âœ… Input validation on all endpoints
- âœ… SQL injection prevention (GORM parameterized queries)
- âœ… XSS protection (output encoding)
- âœ… CORS configuration
- âœ… Request size limits
- âœ… File upload restrictions (type, size)
- âœ… GraphQL query complexity limits
- âœ… GraphQL depth limits
- âœ… Disable introspection in production

### Redis Security

- âœ… Password protection
- âœ… TLS encryption for connections
- âœ… Bind to localhost in development
- âœ… Network isolation in production
- âœ… Regular key expiration cleanup

### Monitoring & Logging

- âœ… Authentication attempt logging
- âœ… Failed authentication alerts
- âœ… Rate limit violation logging
- âœ… Suspicious activity detection
- âœ… Error logging (without sensitive data)

---

## ğŸ“– Documentation Updates

### API Documentation

1. **OpenAPI/Swagger**

   - Update existing REST API docs
   - Add authentication section
   - Document rate limits
   - Add pagination examples

2. **GraphQL Documentation**

   - Schema documentation
   - Example queries
   - Example mutations
   - Best practices guide

3. **Authentication Guide**
   - OAuth flow explanation
   - JWT usage guide
   - Token refresh guide
   - Security best practices

### Developer Documentation

1. **Setup Guide**

   - Supabase configuration
   - Redis setup
   - Environment variables
   - Local development setup

2. **Architecture Documentation**

   - System architecture diagram
   - Data flow diagrams
   - Caching strategy
   - Rate limiting strategy

3. **Integration Guide**
   - REST API examples
   - GraphQL examples
   - Authentication examples
   - Error handling guide

### User Documentation

1. **API Rate Limits**

   - Rate limit tiers
   - How to handle rate limits
   - Request optimization tips

2. **Authentication**
   - How to authenticate
   - OAuth provider options
   - Token management

---

## ğŸš€ Deployment Checklist

### Pre-Deployment

- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] Performance tests meeting targets
- [ ] Security audit completed
- [ ] Documentation updated
- [ ] Environment variables documented
- [ ] Database migrations tested
- [ ] Rollback plan prepared

### Configuration

- [ ] Supabase project configured
- [ ] OAuth providers enabled
- [ ] Redis instance provisioned
- [ ] Environment variables set
- [ ] Rate limits configured
- [ ] Cache TTLs configured
- [ ] CORS settings configured
- [ ] SSL/TLS certificates installed

### Monitoring Setup

- [ ] Application metrics (Prometheus/Grafana)
- [ ] Redis monitoring
- [ ] Database monitoring
- [ ] Error tracking (Sentry)
- [ ] Log aggregation (ELK/Loki)
- [ ] Uptime monitoring
- [ ] Alert notifications configured

### Post-Deployment

- [ ] Smoke tests passed
- [ ] Authentication flow verified
- [ ] Rate limiting verified
- [ ] Cache warming completed
- [ ] Performance monitoring active
- [ ] Error rates normal
- [ ] Documentation published
- [ ] Team notified

---

## ğŸ”„ Migration Path from v1.0.0

### Breaking Changes

- Authentication now required for most endpoints
- Response format changed for list endpoints (added meta and links)
- Rate limits enforced

### Backwards Compatibility

- REST API endpoints remain at same paths
- Existing data models unchanged
- GraphQL is additive (new feature)

### Migration Steps

1. **Week 1**: Deploy Redis and Supabase infrastructure
2. **Week 2**: Enable authentication (optional at first)
3. **Week 3**: Roll out rate limiting with generous limits
4. **Week 4**: Enable caching
5. **Week 5**: Launch GraphQL API (beta)
6. **Week 6**: Make authentication mandatory
7. **Week 7**: Adjust rate limits to target values
8. **Week 8**: GraphQL API general availability

### Communication Plan

- Announce changes 4 weeks before deployment
- Provide migration guide for API consumers
- Offer grace period for authentication
- Gradual rollout of rate limits
- Monitor and adjust based on feedback

---

## ğŸ“ˆ Success Metrics

### Technical Metrics

- **Performance**

  - 40% reduction in average response time
  - 70% cache hit ratio
  - < 5ms rate limiter overhead

- **Reliability**

  - 99.9% uptime
  - < 0.1% error rate
  - Zero security incidents

- **Scalability**
  - Handle 10x current traffic
  - Horizontal scaling support
  - Efficient resource usage

### User Metrics

- **API Usage**

  - 50% adoption of GraphQL within 3 months
  - < 1% rate limit rejections for legitimate users
  - Positive feedback on new features

- **Developer Experience**
  - Reduced integration time by 30%
  - Comprehensive documentation
  - Active community engagement

---

## ğŸ› Risk Assessment & Mitigation

### High Risk

1. **Supabase Integration Complexity**

   - _Risk_: OAuth flow issues, JWT validation problems
   - _Mitigation_: Extensive testing, fallback authentication, comprehensive docs

2. **Cache Invalidation Bugs**

   - _Risk_: Stale data served to users
   - _Mitigation_: Conservative TTLs, manual cache clearing tools, monitoring

3. **Rate Limiting Too Aggressive**
   - _Risk_: Legitimate users blocked
   - _Mitigation_: Start with high limits, monitor closely, adjust based on data

### Medium Risk

1. **Redis Downtime**

   - _Risk_: Application degradation
   - _Mitigation_: Graceful degradation, fallback to non-cached, Redis clustering

2. **GraphQL N+1 Queries**

   - _Risk_: Performance issues
   - _Mitigation_: Dataloaders, query complexity limits, monitoring

3. **Migration Issues**
   - _Risk_: Database inconsistencies
   - _Mitigation_: Backup before migration, tested migrations, rollback scripts

### Low Risk

1. **Documentation Gaps**

   - _Risk_: Poor developer experience
   - _Mitigation_: Comprehensive docs, examples, community feedback

2. **Third-party Service Outages**
   - _Risk_: Temporary unavailability
   - _Mitigation_: Status page, error messages, retry logic

---

## ğŸ“š References & Resources

### Official Documentation

- [Supabase Documentation](https://supabase.com/docs)
- [Redis Documentation](https://redis.io/docs/)
- [gqlgen Documentation](https://gqlgen.com/)
- [JWT Best Practices](https://tools.ietf.org/html/rfc8725)

### Learning Resources

- [GraphQL Best Practices](https://graphql.org/learn/best-practices/)
- [Rate Limiting Algorithms](https://en.wikipedia.org/wiki/Rate_limiting)
- [Caching Strategies](https://aws.amazon.com/caching/best-practices/)

### Tools & Libraries

- [GraphQL Playground](https://github.com/graphql/graphql-playground)
- [Redis Commander](https://github.com/joeferner/redis-commander)
- [k6 Load Testing](https://k6.io/)

---

## ğŸ¯ Next Steps

### Immediate Actions (Week 1)

1. âœ… Review and approve this plan
2. âœ… Set up Supabase project
3. âœ… Create feature branches
4. âœ… Set up development environment
5. âœ… Schedule kickoff meeting

### Continuous Actions

- Daily standups to track progress
- Weekly demos of completed features
- Bi-weekly sprint planning
- Regular code reviews
- Continuous integration/deployment

### Future Considerations (v1.3.0)

- WebSocket support for real-time updates
- GraphQL subscriptions
- Advanced analytics and reporting
- Multi-language support (i18n)
- Content versioning and revision history
- Advanced search with Elasticsearch
- CDN integration for media
- Automated testing and deployment pipelines

---

## ğŸ“ Changelog Template

```markdown
# Changelog

## [1.2.0] - 2026-XX-XX

### Added

- JWT authentication with Supabase Auth integration
- OAuth support (Google, GitHub, etc.)
- Redis caching layer for improved performance
- Distributed rate limiting with Redis
- Pagination, sorting, and filtering for all list endpoints
- GraphQL API with comprehensive schema
- User management and role-based access control
- Session tracking and management
- Query complexity limits for GraphQL
- Dataloader implementation to prevent N+1 queries

### Changed

- Response format for list endpoints (added meta and links)
- Database schema (added users and sessions tables)
- Docker Compose configuration (added Redis service)
- CORS configuration updated for production

### Deprecated

- None

### Removed

- None

### Fixed

- None

### Security

- Implemented JWT-based authentication
- Added rate limiting to prevent abuse
- Enhanced input validation
- Secure session management
- HTTPS enforcement in production
```

---

## âœ… Acceptance Criteria

### Feature Completeness

- [ ] All 5 major features implemented and tested
- [ ] All database migrations successful
- [ ] All endpoints documented
- [ ] All tests passing (unit, integration, performance)

### Performance

- [ ] Response times meet targets
- [ ] Cache hit ratio > 70%
- [ ] Rate limiter overhead < 5ms
- [ ] Load tests passed at 10x traffic

### Security

- [ ] Security audit passed
- [ ] No critical vulnerabilities
- [ ] Authentication flow secure
- [ ] Rate limiting effective

### Documentation

- [ ] API documentation complete
- [ ] Developer guide updated
- [ ] Migration guide published
- [ ] Examples provided

### Deployment

- [ ] Staging deployment successful
- [ ] Production configuration ready
- [ ] Monitoring and alerting configured
- [ ] Rollback plan tested

---

## ğŸ‘¥ Team & Responsibilities

### Backend Developer

- Authentication implementation
- Redis integration
- Rate limiter development
- GraphQL schema and resolvers
- API endpoint updates

### DevOps Engineer

- Redis infrastructure setup
- Supabase configuration
- Deployment automation
- Monitoring setup

### QA Engineer

- Test plan creation
- Unit and integration testing
- Performance testing
- Security testing

### Technical Writer

- API documentation
- User guides
- Migration guides
- Code examples

---

## ğŸ“ Support & Communication

### During Development

- **Daily Standups**: 10 AM (15 minutes)
- **Sprint Planning**: Every 2 weeks
- **Demo Sessions**: End of each sprint
- **Code Reviews**: Within 24 hours

### Issues & Questions

- **GitHub Issues**: Bug reports and feature requests
- **Slack Channel**: Real-time communication
- **Documentation**: First point of reference
- **Team Meetings**: Complex discussions

---

**Document Version:** 1.0  
**Last Updated:** December 2, 2025  
**Status:** Ready for Review  
**Next Review:** After kickoff meeting

---

_This plan is a living document and will be updated as the project progresses._

> > > > > > > Incoming (Background Agent changes)
